<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>literature</title>

<link rel="stylesheet" href="../../../style.css" type="text/css" />

<link rel="stylesheet" href="../../../local.css" type="text/css" />




<link rel="alternate" type="application/x-wiki" title="Edit this page" href="https://github.com/project-renard/project-renard.github.io/edit/source/doc/development/literature/index.tex" />



<link href="./tex4ht.css" rel="stylesheet" type="text/css" />



</head>
<body>

<div class="page">

<div class="pageheader">
<div class="header">
<span>
<span class="parentlinks">

<a href="../../../">Project Renard</a>/ 

<a href="../../">doc</a>/ 

<a href="../">development</a>/ 

</span>
<span class="title">
literature

</span>
</span>



</div>


<div class="actions">
<ul>

<li><a href="https://github.com/project-renard/project-renard.github.io/edit/source/doc/development/literature/index.tex" rel="nofollow">Edit</a></li>


<li><a href="../../../recentchanges/">RecentChanges</a></li>


<li><a href="https://github.com/project-renard/project-renard.github.io/commits/source/doc/development/literature/index.tex">History</a></li>







</ul>
</div>









</div>



<div class="sidebar">
<ul>
    <li><a href="../../../blog/">Blog</a></li>
    <li><a href="../../">Documentation</a></li>
    <ul>
        <li><a href="../../user/">User</a></li>
        <li><a href="../">Development</a></li>
        <ul>
            <li><a href="../meeting-log/">Development meeting log</a></li>
        </ul>
        <li><a href="../../survey/">Survey</a></li>
        <li><a href="../../design/">Design</a></li>
    </ul>
    <li><a href="../../../about/">About</a></li>
</ul>

</div>



<div id="pagebody">

<div id="content">
<body 
>
   <h3 class="sectionHead"><span class="titlemark">1   </span> <a 
 id="x1-10001"></a>Bret Victor</h3>
     <ul class="itemize1">
     <li class="itemize"><a 
href="http://worrydream.com/MediaForThinkingTheUnthinkable/note.html" class="url" ><span 
class="cmtt-10">http://worrydream.com/MediaForThinkingTheUnthinkable/note.html</span></a>
     </li>
     <li class="itemize"><a 
href="http://worrydream.com/MediaForThinkingTheUnthinkable/" class="url" ><span 
class="cmtt-10">http://worrydream.com/MediaForThinkingTheUnthinkable/</span></a>
     </li>
     <li class="itemize"><a 
href="http://worrydream.com/MagicInk/" class="url" ><span 
class="cmtt-10">http://worrydream.com/MagicInk/</span></a>
     </li>
     <li class="itemize"><a 
href="http://worrydream.com/TheHumaneRepresentationOfThought/note.html" class="url" ><span 
class="cmtt-10">http://worrydream.com/TheHumaneRepresentationOfThought/note.html</span></a></li></ul>
<!--l. 75--><p class="noindent" >
</p>
   <h3 class="sectionHead"><span class="titlemark">2   </span> <a 
 id="x1-20002"></a>Alan Kay</h3>
<!--l. 77--><p class="noindent" ><a 
href="https://www.youtube.com/watch?v=YyIQKBzIuBY" class="url" ><span 
class="cmtt-10">https://www.youtube.com/watch?v=YyIQKBzIuBY</span></a>, <a 
href="http://www.tele-task.de/archive/video/flash/14029/" >HPI</a>
</p><!--l. 79--><p class="noindent" >
</p>
   <h3 class="sectionHead"><span class="titlemark">3   </span> <a 
 id="x1-30003"></a>Design of electronic books</h3>
<!--l. 81--><p class="noindent" ><span class="paragraphHead"><a 
 id="x1-40003"></a><a id="bibentry:marshall2009-reading"></a><span 
class="cmbx-10">Reading and Writing the Electronic Book</span><span 
class="cmbx-10"> </span><a 
href="#Xmarshall2009-reading"><span 
class="cmbx-10">Marshall</span></a><span 
class="cmbx-10"> (</span><a 
href="#Xmarshall2009-reading"><span 
class="cmbx-10">2009</span></a><span 
class="cmbx-10">)</span></span>
   <a href="#bibentry:marshall2009-reading">&para;</a>
</p>
<!--l. 83--><p class="noindent" ><span class="paragraphHead"><a 
 id="x1-50003"></a><a id="bibentry:pearson2013-digital-reading"></a><span 
class="cmbx-10">Designing for Digital Reading</span><span 
class="cmbx-10"> </span><a 
href="#Xpearson2013-digital-reading"><span 
class="cmbx-10">Pearson et</span><span 
class="cmbx-10"> al.</span></a><span 
class="cmbx-10"> (</span><a 
href="#Xpearson2013-digital-reading"><span 
class="cmbx-10">2013</span></a><span 
class="cmbx-10">)</span></span>
   <a href="#bibentry:pearson2013-digital-reading">&para;</a>
</p><!--l. 85--><p class="noindent" >
</p>
   <h3 class="sectionHead"><span class="titlemark">4   </span> <a 
 id="x1-60004"></a>Software engineering</h3>
                                                                  

                                                                  
<!--l. 87--><p class="noindent" ><span class="paragraphHead"><a 
 id="x1-70004"></a><a id="bibentry:rosenberg2008-dreaming-code"></a><span 
class="cmbx-10">Dreaming in code: two dozen programmers, three years, 4,732 bugs, and</span>
<span 
class="cmbx-10">one quest for transcendent software</span><span 
class="cmbx-10"> </span><a 
href="#Xrosenberg2008-dreaming-code"><span 
class="cmbx-10">Rosenberg</span></a><span 
class="cmbx-10"> (</span><a 
href="#Xrosenberg2008-dreaming-code"><span 
class="cmbx-10">2008</span></a><span 
class="cmbx-10">)</span></span>
   <a href="#bibentry:rosenberg2008-dreaming-code">&para;</a>
</p><!--l. 89--><p class="noindent" >
</p>
   <h3 class="sectionHead"><span class="titlemark">5   </span> <a 
 id="x1-80005"></a>Workﬂow</h3>
<!--l. 91--><p class="noindent" >In <a 
href="http://ahiddendiscourse.com/2013/02/17/the-cognitive-basis-for-academic-workflows/" >The cognitive basis for academic workﬂows</a>, Lisa D. Harper looks at sensemaking
models as a way to understand academic workﬂows.
</p><!--l. 95--><p class="noindent" >
</p>
   <h3 class="sectionHead"><span class="titlemark">6   </span> <a 
 id="x1-90006"></a>Scene graphs</h3>
<!--l. 97--><p class="noindent" >TODO OpenSceneGraph
</p><!--l. 99--><p class="noindent" >
</p>
   <h3 class="sectionHead"><span class="titlemark">7   </span> <a 
 id="x1-100007"></a>Attribute grammars</h3>
<!--l. 101--><p class="noindent" >Attribute grammars were ﬁrst introduced by Knuth. They consist of a normal
grammar, but augmented with attributes. Attributes are the results of calculations
based on the values and attributes of nodes in the parse tree. <a 
href="#Xknuth1968semantics">Knuth</a> (<a 
href="#Xknuth1968semantics">1968</a>).
</p><!--l. 106--><p class="indent" >   One issue with attributes grammars is determining the order of evaluation. One
naive approach is to use a topological sort based on the dependency graph of the
attributes.
</p>
   <div class="newtheorem">
<!--l. 110--><p class="noindent" ><span class="head">
<a 
 id="x1-10001r1"></a>
<span 
class="cmbx-10">Example 7.1.</span>  </span>Example: Attribute grammar for summing values in list. Taken
from <a 
href="#Xsteinlechner2019attrgrammars">Steinlechner et al.</a> (<a 
href="#Xsteinlechner2019attrgrammars">2019</a>).
</p><!--l. 114--><p class="indent" >   Data structure </p><!--l. 115-->
   <div class="lstlisting" id="listing-1"><span class="label"><a 
 id="x1-10002r1"></a></span>interface List <span 
class="cmsy-10">{</span> <span 
class="cmsy-10">}</span> <br /><span class="label"><a 
 id="x1-10003r2"></a></span>class Cons : List <span 
class="cmsy-10">{</span> <br /><span class="label"><a 
 id="x1-10004r3"></a></span>        Int Value; <br /><span class="label"><a 
 id="x1-10005r4"></a></span>        List Rest; <br /><span class="label"><a 
 id="x1-10006r5"></a></span><span 
class="cmsy-10">}</span> <br /><span class="label"><a 
 id="x1-10007r6"></a></span>class Nil : List <span 
class="cmsy-10">{</span> <span 
class="cmsy-10">}</span>
   
   </div>
<!--l. 124--><p class="indent" >   Attribute grammar (UUAGC syntax) </p><!--l. 125-->
   <div class="lstlisting" id="listing-2"><span class="label"><a 
 id="x1-10008r1"></a></span>syn SEM List <br /><span class="label"><a 
 id="x1-10009r2"></a></span><span 
class="cmsy-10">|</span> Nil  this.Sum = 0 <br /><span class="label"><a 
 id="x1-10010r3"></a></span><span 
class="cmsy-10">|</span> Cons this.Sum = this.Value + this.Rest.Sum
   
                                                                  

                                                                  
   </div>
   </div>
<!--l. 132--><p class="indent" >   In this example, the attribute grammar deﬁnes a <span 
class="cmti-10">synthesised attribute </span><span 
class="cmtt-10">Sum</span>. The
order of evaluation is bottom-up and since this grammar only uses a synthesised
attribute, it is an <span 
class="cmti-10">S-attributed grammar</span>.
</p><!--l. 137--><p class="indent" >   There are also special classes of attribute grammars than can be evaluated in a
single pass during parsing despite having both synthesised attributes and <span 
class="cmti-10">inherited</span>
<span 
class="cmti-10">attributes</span>.
</p><!--l. 141--><p class="indent" >   For a synthesised attribute <!--l. 141--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>&alpha;</mi></mrow></math>
and production <!--l. 141--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>S</mi> <mo 
class="MathClass-rel">&rarr;</mo> <mi 
>A</mi><mi 
>B</mi><mi 
>C</mi></mrow></math> the
semantic function for <!--l. 142--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>S</mi><mo 
class="MathClass-punc">.</mo><mi 
>&alpha;</mi></mrow></math> can
depend on attributes from <!--l. 143--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>A</mi></mrow></math>,
<!--l. 143--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>B</mi></mrow></math>, or
<!--l. 143--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>C</mi></mrow></math>.
</p><!--l. 145--><p class="indent" >   For the inherited attribute <!--l. 145--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>&beta;</mi></mrow></math>
on the same production, <!--l. 146--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>B</mi><mo 
class="MathClass-punc">.</mo><mi 
>&beta;</mi></mrow></math> can
depend on attributes from <!--l. 146--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>S</mi></mrow></math>,
<!--l. 146--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>A</mi></mrow></math>, or
<!--l. 146--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>C</mi></mrow></math>
(every other symbol).
</p><!--l. 149--><p class="indent" >   However, to evaluate a general class of attribute grammars, a speciﬁc traversal
would be needed for each attribute grammar depending on the dependencies for the
semantic functions. There existed algorithms that can take a speciﬁc attribute
grammar and compute a traversal function for an attribute. Some of these are
implemented in the for of a code generating compiler (e.g., UUAGC, JastAdd).
UUAGC which uses a version of the <a 
href="#Xkennedy1976automatic">Kennedy and Warren</a> (<a 
href="#Xkennedy1976automatic">1976</a>)) algorithm that is
described in <a 
href="#Xbransen2012kennedy">Bransen et al.</a> (<a 
href="#Xbransen2012kennedy">2012</a>).
</p><!--l. 159--><p class="indent" >   These algorithms are often used in an ahead of time compiler in order to generate
a static tree-walker evaluator. However, in some applications, an online version may
be useful for dynamic editing of values on the trees or changes to the tree structure
itself (e.g., a language editor). This merges the work in attribute grammars
with work in incremental computing <a 
href="#Xreps1983incremental">Reps et al.</a> (<a 
href="#Xreps1983incremental">1983</a>); <a 
href="#Xramalingam1993categorized">Ramalingam and
Reps</a> (<a 
href="#Xramalingam1993categorized">1993</a>).
</p><!--l. 167--><p class="indent" >   In order to use attribute grammars in a way that they can be composible (in FP,
AGs can be used to deﬁne catamorphisms compositionally) and easy to write,
there has been work on making embedded DSLs for AG deﬁnitions <a 
href="#Xsloane2010pure">Sloane
et al.</a> (<a 
href="#Xsloane2010pure">2010</a>).
</p><!--l. 173--><p class="noindent" >
</p>
   <h3 class="sectionHead"><span class="titlemark">8   </span> <a 
 id="x1-110008"></a>Incremental computing</h3>
                                                                  

                                                                  
<!--l. 175--><p class="noindent" >
</p>
   <h3 class="sectionHead"><span class="titlemark">9   </span> <a 
 id="x1-120009"></a>Self-adjusting computation</h3>
<!--l. 1--><p class="noindent" >
</p>
   <h3 class="likesectionHead"><a 
 id="x1-130009"></a>References</h3>
<!--l. 1--><p class="noindent" >
  </p><div class="thebibliography">
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xbransen2012kennedy"></a><span class="bibsp">   </span></span>Jeroen Bransen, Arie Middelkoop, Atze Dijkstra, and S Doaitse Swierstra. The
  kennedy-warren algorithm revisited: ordering attribute grammars. In <span 
class="cmti-10">International</span>
  <span 
class="cmti-10">Symposium on Practical Aspects of Declarative Languages</span>, pages 183–197.
  Springer, 2012. doi: 10.1007/978-<mstyle 
class="mbox"><mtext  >_</mtext></mstyle>3-<mstyle 
class="mbox"><mtext  >_</mtext></mstyle>642-<mstyle 
class="mbox"><mtext  >_</mtext></mstyle>27694-<mstyle 
class="mbox"><mtext  >_</mtext></mstyle>1<mstyle 
class="mbox"><mtext  >_</mtext></mstyle>14.
         </p><div class="quotation">
      <p class="bibitem-p" ><span 
class="cmbx-10">Abstract: </span>Attribute  Grammars  (AGs)  are  a  powerful  tool  for
      deﬁning an executable semantics of a programming language, and
      thus for implementing a compiler. An execution plan for an AG
      determines a static evaluation order for the attributes which are
      deﬁned  as  part  of  an  AG  speciﬁcation.  In  building  the  Utrecht
      Haskell Compiler (UHC), a large scale AG project, we discovered
      that the Ordered AG approach (Kastens, 1980) for building such
      plans becomes impractical: the additional dependencies between
      attributes introduced by this algorithm too often result in grammars
      for  which  no  execution  plan  can  be  generated.  To  avoid  such
      problems we have implemented a reﬁned version of the algorithm
      of Kennedy and Warren (1976) as part of our purely functional
      AG system and show how this algorithm solves the problems that
      surface with the Ordered AG approach. Furthermore, we present
      the results of applying this algorithm to the UHC code and show
      that this approach in some cases also has a positive eﬀect on the
      runtime of the resulting program.</p></div>
  <p class="bibitem-p" >URL <a 
href="http://dx.doi.org/10.1007/978-3-642-27694-1_14" class="url" ><span 
class="cmtt-10">http://dx.doi.org/10.1007/978-_3-_642-_27694-_1_14</span></a>.
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xkennedy1976automatic"></a><span class="bibsp">   </span></span>Ken Kennedy and Scott K Warren. Automatic generation of eﬃcient evaluators
  for attribute grammars. In <span 
class="cmti-10">Proceedings of the 3rd ACM SIGACT-SIGPLAN</span>
  <span 
class="cmti-10">symposium on Principles on programming languages</span>, pages 32–49. ACM, 1976.
  doi: 10.1145/800168.811538.
         </p><div class="quotation">
                                                                  

                                                                  
      <p class="bibitem-p" ><span 
class="cmbx-10">Abstract: </span>The translation process may be divided into a syntactic
      phase and a semantic phase. Context-free grammars can be used
      to  describe  the  set  of  syntactically  correct  source  texts  in  a
      formal  yet  intuitively  appealing  way,  and  many  techniques  are
      now  known  for  automatically  constructing  parsers  from  given
      CF grammars. Knuth&#x2019;s attribute grammars oﬀer the prospect of
      similarly automating the implementation of the semantic phase.
      An attribute grammar is an ordinary CF grammar extended to
      specify the meaning of each string in the language. Each grammar
      symbol has an associated set of attributes:, and each production
      rule is provided with corresponding semantic rules expressing the
      relationships between the attributes of symbols in the production.
      To ﬁnd the meaning of a string, ﬁrst we ﬁnd its parse tree and then
      we determine the values of all the attributes of symbols in the tree.</p></div>
  <p class="bibitem-p" >URL <a 
href="http://dx.doi.org/10.1145/800168.811538" class="url" ><span 
class="cmtt-10">http://dx.doi.org/10.1145/800168.811538</span></a>.
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xknuth1968semantics"></a><span class="bibsp">   </span></span>Donald E Knuth. Semantics of context-free languages. <span 
class="cmti-10">Mathematical systems</span>
  <span 
class="cmti-10">theory</span>, 2(2):127–145, 1968. doi: 10.1007/bf01692511.
         </p><div class="quotation">
      <p class="bibitem-p" ><span 
class="cmbx-10">Abstract: </span>Meaning may be assigned to a string in a context-free
      language  by  deﬁning  attributes  of  the  symbols  in  a  derivation
      tree for that string. The attributes can be deﬁned by functions
      associated  with  each  production  in  the  grammar.  This  paper
      examines  the  implications  of  this  process  when  some  of  the
      attributes are synthesized, i.e., deﬁned solely in terms of attributes
      of the descendants of the corresponding nonterminal symbol, while
      other attributes are inherited, i.e., deﬁned in terms of attributes
      of the ancestors of the nonterminal symbol. An algorithm is given
      which  detects  when  such  semantic  rules  could  possibly  lead  to
      circular  deﬁnition  of  some  attributes.  An  example  is  given  of  a
      simple  programming  language  deﬁned  with  both  inherited  and
      synthesized attributes, and the method of deﬁnition is compared to
      other techniques for formal speciﬁcation of semantics which have
      appeared in the literature.</p></div>
  <p class="bibitem-p" >URL <a 
href="http://dx.doi.org/10.1007/bf01692511" class="url" ><span 
class="cmtt-10">http://dx.doi.org/10.1007/bf01692511</span></a>.
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xmarshall2009-reading"></a><span class="bibsp">   </span></span>Catherine C. Marshall. <span 
class="cmti-10">Reading and Writing the Electronic Book</span>, volume 1.
  Morgan &#x0026; Claypool Publishers, 2009. doi: 10.2200/S00215ED1V01Y200907ICR009.
         </p><div class="quotation">
                                                                  

                                                                  
      <p class="bibitem-p" ><span 
class="cmbx-10">Abstract: </span>Developments over the last twenty years have fueled
      considerable  speculation  about  the  future  of  the  book  and  of
      reading itself. This book begins with a gloss over the history of
      electronic books, including the social and technical forces that have
      shaped their development. The focus then shifts to reading and
      how we interact with what we read: basic issues such as legibility,
      annotation,  and  navigation  are  examined  as  aspects  of  reading
      that  ebooks  inherit  from  their  print  legacy.  Because  reading  is
      fundamentally  communicative,  I  also  take  a  closer  look  at  the
      sociality of reading: how we read in a group and how we share what
      we read. Studies of reading and ebook use are integrated throughout
      the book, but Chapter 5 “goes meta” to explore how a researcher
      might go about designing his or her own reading-related studies.
      No book about ebooks is complete without an explicit discussion of
      content preparation, i.e., how the electronic book is written. Hence,
      Chapter 6 delves into the underlying representation of ebooks and
      eﬀorts to create and apply markup standards to them. This chapter
      also examines how print genres have made the journey to digital
      and how some emerging digital genres might be realized as ebooks.
      Finally, Chapter 7 discusses some beyond-the-book functionality:
      how can ebook platforms be transformed into portable personal
      libraries?  In  the  end,  my  hope  is  that  by  the  time  the  reader
      reaches the end of this book, he or she will feel equipped to perform
      the next set of studies, write the next set of articles, invent new
      ebook functionality, or simply engage in a heated argument with the
      stranger in seat 17C about the future of reading. Table of Contents:
      Preface / Figure Credits / Introduction / Reading / Interaction
      / Reading as a Social Activity / Studying Reading / Beyond the
      Book / References / Author Biography</p></div>
  <p class="bibitem-p" >URL <a 
href="http://dx.doi.org/10.2200/S00215ED1V01Y200907ICR009" class="url" ><span 
class="cmtt-10">http://dx.doi.org/10.2200/S00215ED1V01Y200907ICR009</span></a>.
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xpearson2013-digital-reading"></a><span class="bibsp">   </span></span>Jennifer Pearson, George Buchanan, and Harold Thimbleby. <span 
class="cmti-10">Designing for</span>
  <span 
class="cmti-10">Digital Reading</span>, volume 5.  Morgan &#x0026; Claypool Publishers, 2013.  doi:
  10.2200/S00539ED1V01Y201310ICR029.
         </p><div class="quotation">
      <p class="bibitem-p" ><span 
class="cmbx-10">Abstract: </span>Reading is a complex human activity that has evolved,
      and  co-evolved,  with  technology  over  thousands  of  years.  Mass
      printing in the ﬁfteenth century ﬁrmly established what we know
      as the modern book, with its physical format of covers and paper
      pages, and now-standard features such as page numbers, footnotes,
      and diagrams. Today, electronic documents are enabling paperless
      reading supported by eReading technologies such as Kindles and
                                                                  

                                                                  
      Nooks, yet a high proportion of users still opt to print on paper
      before reading. This persistent habit of “printing to read” is one
      sign  of  the  shortcomings  of  digital  documents  –  although  the
      popularity of eReaders is one sign of the shortcomings of paper.
      How do we get the best of both worlds? The physical properties
      of paper (for example, it is light, thin, and ﬂexible) contribute to
      the ease with which physical documents are manipulated; but these
      properties have a completely diﬀerent set of aﬀordances to their
      digital equivalents. Paper can be folded, ripped, or scribbled on
      almost subconsciously – activities that require signiﬁcant cognitive
      attention  in  their  digital  form,  if  they  are  even  possible.  The
      nearly  subliminal  interaction  that  comes  from  years  of  learned
      behavior with paper has been described as lightweight interaction,
      which  is  achieved  when  a  person  actively  reads  an  article  in  a
      way  that  is  so  easy  and  unselfconscious  that  they  are  not  apt
      to  remember  their  actions  later.  Reading  is  now  in  a  period  of
      rapid change, and digital text is fast becoming the predominant
      mode  of  reading.  As  a  society,  we  are  merely  at  the  start  of
      the journey of designing truly eﬀective tools for handling digital
      text.  This  book  investigates  the  advantages  of  paper,  how  the
      aﬀordances  of  paper  can  be  realized  in  digital  form,  and  what
      forms best support lightweight interaction for active reading. To
      understand how to design for the future, we review the ways reading
      technology and reader behavior have both changed and remained
      constant over hundreds of years. We explore the reasoning behind
      reader behavior and introduce and evaluate several user interface
      designs that implement these lightweight properties familiar from
      our everyday use of paper. We start by looking back, reviewing the
      development of reading technology and the progress of research on
      reading over many years. Drawing key concepts from this review,
      we move forward to develop and test methods for creating new and
      more eﬀective interactions for supporting digital reading. Finally,
      we  lay  down  a  set  of  lightweight  attributes  which  can  be  used
      as  evidence-based  guidelines  to  improve  the  usability  of  future
      digital  reading  technologies.  By  the  end  of  this  book,  then,  we
      hope you will be equipped to critique the present state of digital
      reading, and to better design and evaluate new interaction styles
      and technologies. Table of Contents: Preface / Acknowledgments /
      Figure Credits / Introduction / Reading Through the Ages / Key
      Concepts / Lightweight Interactions / Improving Digital Reading
      / Bibliography / Authors&#x2019; Biographies</p></div>
  <p class="bibitem-p" >URL <a 
href="http://dx.doi.org/10.2200/S00539ED1V01Y201310ICR029" class="url" ><span 
class="cmtt-10">http://dx.doi.org/10.2200/S00539ED1V01Y201310ICR029</span></a>.
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xramalingam1993categorized"></a><span class="bibsp">   </span></span>Ganesan Ramalingam and Thomas Reps. A categorized bibliography on
                                                                  

                                                                  
  incremental computation. In <span 
class="cmti-10">Proceedings of the 20th ACM SIGPLAN-SIGACT</span>
  <span 
class="cmti-10">symposium on Principles of programming languages</span>, pages 502–510. ACM, 1993.
  doi: 10.1145/158511.158710. URL <a 
href="http://dx.doi.org/10.1145/158511.158710" class="url" ><span 
class="cmtt-10">http://dx.doi.org/10.1145/158511.158710</span></a>.
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xreps1983incremental"></a><span class="bibsp">   </span></span>Thomas Reps, Tim Teitelbaum, and Alan Demers. Incremental context-dependent
  analysis for language-based editors. <span 
class="cmti-10">ACM Transactions on Programming</span>
  <span 
class="cmti-10">Languages and Systems (TOPLAS)</span>, 5(3):449–477, 1983. doi: 10.1145/2166.357218.
         </p><div class="quotation">
      <p class="bibitem-p" ><span 
class="cmbx-10">Abstract:  </span>Knowledge  of  a  programming  language&#x2019;s  grammar
      allows language-based editors to enforce syntactic correctness at
      all times during development by restricting editing operations to
      legitimate modiﬁcations of the program&#x2019;s context-free derivation
      tree; however, not all language constraints can be enforced in this
      way because not all features can be described by the context-free
      formalism. Attribute grammars permit context-dependent language
      features  to  be  expressed  in  a  modular,  declarative  fashion  and
      thus are a good basis for specifying language-based editors. Such
      editors represent programs as attributed trees, Which are modiﬁed
      by operations such as subtree pruning and grafting. Incremental
      analysis  is  performed  by  updating  attribute  values  after  every
      modiﬁcation. This paper discusses how updating can be carried out
      and presents several algorithms for the task, including one that is
      asymptotically optimal in time.</p></div>
  <p class="bibitem-p" >URL <a 
href="http://dx.doi.org/10.1145/2166.357218" class="url" ><span 
class="cmtt-10">http://dx.doi.org/10.1145/2166.357218</span></a>.
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xrosenberg2008-dreaming-code"></a><span class="bibsp">   </span></span>Scott Rosenberg. <span 
class="cmti-10">Dreaming in code: two dozen programmers, three years, 4,732</span>
  <span 
class="cmti-10">bugs, and one quest for transcendent software</span>. Three Rivers Press (CA), 2008.
  ISBN 978-1-400-08246-9.
         </p><div class="quotation">
      <p class="bibitem-p" ><span 
class="cmbx-10">Abstract:  </span>Our  civilization  runs  on  software.  Yet  the  art  of
      creating it continues to be a dark mystery, even to the experts.
      To ﬁnd out why its so hard to bend computers to our will, Scott
      Rosenberg spent three years following a team of maverick software
      developersled by Lotus 1-2-3 creator Mitch Kapordesigning a novel
      personal information manager meant to challenge market leader
      Microsoft Outlook. Their story takes us through a maze of abrupt
      dead ends and exhilarating breakthroughs as they wrestle not only
      with the abstraction of code, but with the unpredictability of human
      behaviorespecially their own.</p></div>
                                                                  

                                                                  
  <p class="bibitem-p" >URL <a 
href="http://www.dreamingincode.com/" class="url" ><span 
class="cmtt-10">http://www.dreamingincode.com/</span></a>.
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xsloane2010pure"></a><span class="bibsp">   </span></span>Anthony M Sloane, Lennart CL Kats, and Eelco Visser. A pure object-oriented
  embedding of attribute grammars. <span 
class="cmti-10">Electronic Notes in Theoretical Computer</span>
  <span 
class="cmti-10">Science</span>, 253(7):205–219, 2010. doi: 10.1016/j.entcs.2010.08.043.
         </p><div class="quotation">
      <p class="bibitem-p" ><span 
class="cmbx-10">Abstract:  </span>Attribute  grammars  are  a  powerful  speciﬁcation
      paradigm for many language processing tasks, particularly semantic
      analysis  of  programming  languages.  Recent  attribute  grammar
      systems use dynamic scheduling algorithms to evaluate attributes
      by  need.  In  this  paper,  we  show  how  to  remove  the  need  for
      a  generator,  by  embedding  a  dynamic  approach  in  a  modern,
      object-oriented  programming  language  to  implement  a  small,
      lightweight  attribute  grammar  library.  The  Kiama  attribution
      library has similar features to current generators, including cached,
      uncached,  circular,  higher-order  and  parameterised  attributes,
      and  implements  new  techniques  for  dynamic  extension  and
      variation of attribute equations. We use the Scala programming
      language  because  of  its  combination  of  object-oriented  and
      functional  features,  support  for  domain-speciﬁc  notations  and
      emphasis on scalability. Unlike generators with specialised notation,
      Kiama  attribute  grammars  use  standard  Scala  notations  such
      as  pattern-matching  functions  for  equations  and  mixins  for
      composition. A performance analysis shows that our approach is
      practical for realistic language processing.</p></div>
  <p class="bibitem-p" >URL <a 
href="http://dx.doi.org/10.1016/j.entcs.2010.08.043" class="url" ><span 
class="cmtt-10">http://dx.doi.org/10.1016/j.entcs.2010.08.043</span></a>.
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xsteinlechner2019attrgrammars"></a><span class="bibsp">   </span></span>Harald Steinlechner, Georg Haaser, Stefan Maierhofer, and Robert Tobler.
  Attribute grammars for incremental scene graph rendering. pages 77–88.
  SCITEPRESS - Science and Technology Publications, 02 2019.  ISBN
  9789897583544. doi: 10.5220/0007372800770088.
         </p><div class="quotation">
      <p class="bibitem-p" ><span 
class="cmbx-10">Abstract: </span>Scene graphs, as found in many visualization systems
      are  a  well-established  concept  for  modeling  virtual  scenes  in
      computer  graphics.  State-of-the-art  approaches  typically  issue
      appropriate draw commands while traversing the graph. Equipped
      with  a  functional  programming  mindset  we  take  a  diﬀerent
      approach and utilize attribute grammars as a central concept for
      modeling the problem domain declaratively. Instead of issuing draw
                                                                  

                                                                  
      commands imperatively, we synthesize ﬁrst class objects describing
      appropriate  draw  commands.  In  order  to  make  this  approach
      practical  in  the  face  of  dynamic  changes  to  the  scene  graph,
      we  utilize  incremental  evaluation,  and  thereby  avoid  repeated
      evaluation  of  unchanged  parts.  Our  application  prototypically
      demonstrates how complex systems beneﬁt from domain-speciﬁc
      languages,  declarative  problem  solving  and  the  implications
      thereof. Besides from being concise and expressive, our solution
      demonstrates a real-world use case of self-adjusting computation
      which  elegantly  extends  scene  graphs  with  well-deﬁned  reactive
      semantics and eﬃcient, incremental execution.</p></div>
  <p class="bibitem-p" >URL <a 
href="http://dx.doi.org/10.5220/0007372800770088" class="url" ><span 
class="cmtt-10">http://dx.doi.org/10.5220/0007372800770088</span></a>.
</p>
  </div>
    

</div>







</div>

<div id="footer" class="pagefooter">

<div id="pageinfo">












<div class="pagedate">
Last edited <span class="date">Mon 20 May 2019 09:10:56 PM UTC</span>
<!-- Created <span class="date">Mon 08 Jan 2018 08:58:49 AM UTC</span> -->
</div>

</div>


<!-- from Project Renard -->
</div>

</div>

</body>
</html>
